[["index.html", "R visualizations Chapter 1 About 1.1 Usage 1.2 Render book 1.3 Preview book", " R visualizations Juho Mononen 2025-03-03 Chapter 1 About This is a sample book written in Markdown. You can use anything that Pandoc’s Markdown supports; for example, a math equation \\(a^2 + b^2 = c^2\\). 1.1 Usage Each bookdown chapter is an .Rmd file, and each .Rmd file can contain one (and only one) chapter. A chapter must start with a first-level heading: # A chapter, and can contain one (and only one) first-level heading. Use second-level and higher headings within chapters like: ## A short section or ### An even shorter section. The index.Rmd file is required, and is also your first book chapter. It will be the homepage when you render the book. 1.2 Render book Render the book from the R console: bookdown::render_book() Or if you want to add just one chapter or to a chapter 1.3 Preview book As you work, you may start a local server to live preview this HTML book. This preview will update as you edit the book when you save individual .Rmd files. You can start the server in a work session by using the RStudio add-in “Preview book”, or from the R console: bookdown::serve_book() "],["ggplot2.html", "Chapter 2 ggplot2 2.1 Packages needed for these examples 2.2 Boxplots 2.3 Volcano plots", " Chapter 2 ggplot2 2.1 Packages needed for these examples ggplot2 for the main plotting functions forcats for easy factor releveling ggrepel for better in-plot labeling ggpubr for easy signifigance bars and testing library(ggplot2) library(forcats) library(ggrepel) library(ggpubr) 2.2 Boxplots 2.2.1 Boxplot examples with iris data Setup the data in long format which is better suited for ggplot2. long_iris &lt;- reshape(data = iris, direction = &quot;long&quot;, timevar = &quot;Dimension&quot;, times = colnames(iris)[1:4], idvar = &quot;flower_ID&quot;, ids = paste0(&quot;f&quot;, 1:150), v.names = &quot;Length&quot;, varying = 1:4, new.row.names = 1:600) forcats::fct_reorder() used here to reorder factor levels for both Species (ascending left to right) and Sepal/Petal lengths. ggplot(long_iris, mapping = aes(x=forcats::fct_reorder(Species, Length), # reorder by measurements y=Length, colour=forcats::fct_reorder(Dimension, Length))) + # reorder by measurements # Define fill as a alpha shade of colour aesthetic geom_boxplot(mapping = aes(fill = after_scale(alpha(colour, 0.4)))) + # Set colours manually scale_color_manual(name=&quot;Dimension&quot;, values = c(&quot;dodgerblue&quot;, &quot;red1&quot;, &quot;dodgerblue4&quot;, &quot;red4&quot;)) + # Set y-axis to end on tick, you could use c(0,0) but expansion offers more customization i.e. non-symmetrical expansion of axis scale_y_continuous(name = &quot;Measurement (mm)&quot;, expand = expansion(mult = 0), limits = c(0,9), breaks = seq(0,9,3)) + theme_classic(13) + # Modify theme theme(title = element_text(face=&quot;bold&quot;), legend.title = element_blank(), axis.text = element_text(colour=&quot;black&quot;), axis.title.x = element_blank(), axis.ticks.length = unit(0.5, &quot;lines&quot;), panel.grid.major.y = element_line(colour = ggplot2::alpha(&quot;black&quot;, 0.4), linetype = &quot;dashed&quot;), legend.position = &quot;inside&quot;, legend.position.inside = c(0.12, 0.85), ) Sometimes we want to facet which enables a bit nicer X-axis options e.g. separating axis for different species. This also enables possibility to use ggpubr::stat_compare_means for testing. # Comparisons to use for testing my_comparisons &lt;- list( c(&quot;Petal.Width&quot;, &quot;Sepal.Width&quot;), c(&quot;Petal.Length&quot;, &quot;Sepal.Length&quot;)) # For testing we need to set the groups in the comparison on X-axis ggplot(long_iris, mapping = aes(x=forcats::fct_reorder(Dimension, Length), y=Length, colour=forcats::fct_reorder(Dimension, Length))) + geom_boxplot(mapping = aes(fill = after_scale(alpha(colour, 0.4)))) + # P-value labeling using asterix ggpubr::stat_compare_means(mapping = aes(label = after_stat(p.signif)), comparisons = my_comparisons, label.y = c(8,8)) + scale_color_manual(name=&quot;Dimension&quot;, values = c(&quot;dodgerblue&quot;, &quot;red1&quot;, &quot;dodgerblue4&quot;, &quot;red4&quot;)) + scale_y_continuous(name = &quot;Measurement (mm)&quot;, expand = expansion(mult = 0), limits = c(0,9), breaks = seq(0,9,3)) + # faceting and reordering the facets facet_wrap(~forcats::fct_reorder(Species, Length), strip.position=&quot;bottom&quot;) + theme_classic(13) + theme(title = element_text(face=&quot;bold&quot;), axis.text = element_text(colour=&quot;black&quot;), axis.title.x = element_blank(), axis.ticks.length = unit(0.5, &quot;lines&quot;), axis.ticks.x = element_blank(), strip.background = element_blank(), strip.placement = &quot;outside&quot;, axis.text.x = element_blank(), panel.grid.major.y = element_line(colour = ggplot2::alpha(&quot;black&quot;, 0.4), linetype = &quot;dashed&quot;) ) 2.3 Volcano plots 2.3.1 Volcano plot from the airway dataset Some example volcano plots using airway dataset. First we have to perform de_analysis as the data is unprocessed. library(airway) library(DESeq2) data(&quot;airway&quot;) # Perform DEA dds &lt;- DESeqDataSet(airway, design = ~ cell + dex) dds &lt;- DESeq(dds, betaPrior=FALSE) res &lt;- results(dds, contrast = c(&#39;dex&#39;,&#39;trt&#39;,&#39;untrt&#39;)) res &lt;- lfcShrink(dds, contrast = c(&#39;dex&#39;,&#39;trt&#39;,&#39;untrt&#39;), res=res, type = &#39;normal&#39;) # Make data.frame for plotting res_df &lt;- as.data.frame(res) res_df$ensid &lt;- rownames(res_df) res_df$gene_name &lt;- airway@rowRanges@elementMetadata@listData$gene_name[match(airway@rowRanges@elementMetadata@listData$gene_id, res_df$ensid)] # DO NOT DO THIS WITH REAL DATA WITHOUT KNOWING WHAT YOU ARE ACTUALLY REMOVING HERE res_df &lt;- na.omit(res_df) Simple volcano with labeling using ggrepel::geom_text_repel(). ggplot(na.omit(res_df), mapping = aes(x=log2FoldChange, y=-log10(padj), colour=factor(ifelse(padj&lt;0.01 &amp; abs(log2FoldChange)&gt;1, &quot;Sig.&quot;, &quot;NS&quot;), levels = c(&quot;Sig.&quot;, &quot;NS&quot;)))) + geom_point(alpha=0.8) + scale_color_manual(values = c(scales::muted(&quot;red&quot;), ggplot2::alpha(&quot;grey80&quot;, 0.8))) + ggrepel::geom_text_repel(mapping = aes(label = ifelse(padj&lt;1e-50 &amp; abs(log2FoldChange)&gt;2.5, gene_name, &quot;&quot;)), box.padding = 1, seed=1234, size=2, max.overlaps = Inf, min.segment.length = 0) + theme_bw() + # add cutoffs geom_vline(xintercept = c(-1,1), linetype = &quot;dashed&quot;) + geom_hline(yintercept = -log10(0.01), linetype = &quot;dashed&quot;) + # Using bquote for subscripts scale_y_continuous(name = bquote(bold(-log[10](FDR))), expand = expansion(mult = 0), limits = c(0,150), breaks = seq(0,150,50)) + scale_x_continuous(name = bquote(bold(log[2](Fold~change))), expand = expansion(mult = 0), limits = c(-5,5), breaks = seq(-5,5,2.5)) + # prevent clipping of the panel borders coord_cartesian(clip = &quot;off&quot;) + theme(axis.title = element_text(face=&quot;bold&quot;), axis.text = element_text(colour=&quot;black&quot;), axis.ticks.length = unit(0.5, &quot;lines&quot;), axis.line = element_blank(), panel.border = element_rect(colour = &quot;black&quot;), legend.title = element_blank(), panel.grid = element_blank(), legend.position = &quot;inside&quot;, legend.position.inside = c(0.1,0.9), legend.background = element_blank()) For a bit more customizable plots we can separate significant and non-significant DEGs # create dataframe for significant DEGs res_df_sig &lt;- res_df[res_df$padj&lt;0.01 &amp; abs(res_df$log2FoldChange)&gt;1,] # Create dataframe for non significant res_df_nsig &lt;- res_df[!(res_df$gene_name %in% res_df_sig$gene_name),] More classic version with up and down regulated genes with different colours. ggplot() + geom_point(data = res_df_nsig, mapping= aes(x=log2FoldChange, y=-log10(padj)), colour=&quot;grey80&quot;, alpha=0.4) + geom_point(data = res_df_sig, mapping= aes(x=log2FoldChange, y=-log10(padj), colour=factor(ifelse(log2FoldChange&gt;0, &quot;Up&quot;, &quot;Down&quot;), levels = c(&quot;Up&quot;, &quot;Down&quot;))), alpha=0.8) + scale_colour_manual(values = c(&quot;darkred&quot;, &quot;dodgerblue4&quot;)) + theme_bw() + geom_vline(xintercept = c(-1,1), linetype = &quot;dashed&quot;) + geom_hline(yintercept = -log10(0.01), linetype = &quot;dashed&quot;) + scale_y_continuous(name = bquote(bold(-log[10](FDR))), expand = expansion(mult = 0), limits = c(0,150), breaks = seq(0,150,50)) + scale_x_continuous(name = bquote(bold(log[2](Fold~change))), expand = expansion(mult = 0), limits = c(-5,5), breaks = seq(-5,5,2.5)) + # prevent clipping of the panel borders coord_cartesian(clip = &quot;off&quot;) + theme(axis.title = element_text(face=&quot;bold&quot;), axis.text = element_text(colour=&quot;black&quot;), axis.ticks.length = unit(0.5, &quot;lines&quot;), axis.line = element_blank(), panel.border = element_rect(colour = &quot;black&quot;), legend.title = element_blank(), panel.grid = element_blank(), legend.position = &quot;none&quot;) Some times it can be interesting to see how the DEGs are separated into up- and down-regulated ones. We can calculate densities in 2d space using MASS and map the values to points in the graph. #For calculating density get_density &lt;- function(x, y, ...) { dens &lt;- MASS::kde2d(x, y, ...) ix &lt;- findInterval(x, dens$x) iy &lt;- findInterval(y, dens$y) ii &lt;- cbind(ix, iy) return(dens$z[ii]) } # calculate densities for points res_df_sig$density &lt;- get_density(-log10(res_df_sig$padj), res_df_sig$log2FoldChange) # plot separately ggplot() + geom_point(data = res_df_nsig, mapping= aes(x=log2FoldChange, y=-log10(padj)), colour=&quot;grey80&quot;, alpha=0.4) + geom_point(data = res_df_sig, mapping= aes(x=log2FoldChange, y=-log10(padj), colour=density), alpha=0.8) + scale_color_viridis_c() + theme_bw() + geom_vline(xintercept = c(-1,1), linetype = &quot;dashed&quot;) + geom_hline(yintercept = -log10(0.01), linetype = &quot;dashed&quot;) + scale_y_continuous(name = bquote(bold(-log[10](FDR))), expand = expansion(mult = 0), limits = c(0,150), breaks = seq(0,150,50)) + scale_x_continuous(name = bquote(bold(log[2](Fold~change))), expand = expansion(mult = 0), limits = c(-5,5), breaks = seq(-5,5,2.5)) + # prevent clipping of the panel borders coord_cartesian(clip = &quot;off&quot;) + theme(axis.title = element_text(face=&quot;bold&quot;), axis.text = element_text(colour=&quot;black&quot;), axis.ticks.length = unit(0.5, &quot;lines&quot;), axis.line = element_blank(), panel.border = element_rect(colour = &quot;black&quot;), legend.title = element_blank(), panel.grid = element_blank(), legend.position = &quot;none&quot;) "],["complexheatmap.html", "Chapter 3 ComplexHeatmap 3.1 Heatmap examples with airway dataset 3.2 Complex heatmap plot for CEMiTool results", " Chapter 3 ComplexHeatmap library(ComplexHeatmap) 3.1 Heatmap examples with airway dataset 3.1.1 Simple counts heatmap library(airway) library(DESeq2) data(&quot;airway&quot;) # Perform DEA dds &lt;- DESeqDataSet(airway, design = ~ cell + dex) dds &lt;- DESeq(dds, betaPrior=FALSE) ## estimating size factors ## estimating dispersions ## gene-wise dispersion estimates ## mean-dispersion relationship ## final dispersion estimates ## fitting model and testing res &lt;- results(dds, contrast = c(&#39;dex&#39;,&#39;trt&#39;,&#39;untrt&#39;)) res &lt;- lfcShrink(dds, contrast = c(&#39;dex&#39;,&#39;trt&#39;,&#39;untrt&#39;), res=res, type = &#39;normal&#39;) ## using &#39;normal&#39; for LFC shrinkage, the Normal prior from Love et al (2014). ## ## Note that type=&#39;apeglm&#39; and type=&#39;ashr&#39; have shown to have less bias than type=&#39;normal&#39;. ## See ?lfcShrink for more details on shrinkage type, and the DESeq2 vignette. ## Reference: https://doi.org/10.1093/bioinformatics/bty895 # normalize counts dds &lt;- vst(dds) top_anno &lt;- HeatmapAnnotation(df = meta_col[,c(&quot;dex&quot;,&quot;cell&quot;)], col = list(dex = c(&quot;trt&quot;=&quot;darkred&quot;, &quot;untrt&quot;=&quot;dodgerblue4&quot;), cell = c(N052611=&quot;#009E73&quot;, N061011=&quot;#D55E00&quot;, N080611=&quot;#56B4E9&quot;, N61311=&quot;#F0E442&quot;)), border = TRUE) draw( Heatmap(t(scale(t(mat))), name = &quot;Z-score&quot;, border=TRUE, show_row_names = FALSE, show_row_dend = FALSE, show_column_names = FALSE, top_annotation = top_anno), merge_legend=TRUE) Usually with such a simple result (clear two groups) it is better to not use annotations and instead use text annotation ht = draw( Heatmap(t(scale(t(mat))), name = &quot;Z-score&quot;, show_row_names = FALSE, show_row_dend = FALSE, # split to get titles column_split = meta_col$dex, # set dend split invisible show_parent_dend_line = FALSE, # set gap to zero for split column_gap = unit(0, &quot;lines&quot;), column_title_gp = gpar(fontface=&quot;bold&quot;), show_column_names = FALSE, column_dend_side = &quot;bottom&quot;), merge_legend=TRUE) # add annotation lines decorate_column_title(&quot;Z-score&quot;, { grid.lines(x = c(0.1,0.9), y=0.2) grid.lines(x = c(1.1,1.9), y=0.2) }) 3.2 Complex heatmap plot for CEMiTool results library(CEMiTool) library(simplifyEnrichment) library(dplyr) First lets generate necessary # Get cemitools object and GMT for pathways data(&quot;cem&quot;) gmt_fname &lt;- system.file(&quot;extdata&quot;, &quot;pathways.gmt&quot;, package = &quot;CEMiTool&quot;) gmt_in &lt;- read_gmt(gmt_fname) # perform over representation analysis cem &lt;- mod_ora(cem, gmt_in) # Perform module enrichment cem &lt;- mod_gsea(cem) ## Warning in fgseaMultilevel(pathways = pathways, stats = stats, minSize = minSize, : There were 1 ## pathways for which P-values were not calculated properly due to unbalanced (positive and negative) ## gene-level statistic values. For such pathways pval, padj, NES, log2err are set to NA. You can try ## to increase the value of the argument nPermSimple (for example set it nPermSimple = 10000) ## Warning in fgseaMultilevel(pathways = pathways, stats = stats, minSize = minSize, : There were 3 ## pathways for which P-values were not calculated properly due to unbalanced (positive and negative) ## gene-level statistic values. For such pathways pval, padj, NES, log2err are set to NA. You can try ## to increase the value of the argument nPermSimple (for example set it nPermSimple = 10000) module_genes &lt;- module_genes(cem) module_genes &lt;- module_genes[module_genes$modules != &quot;Not.Correlated&quot;, ] exp_mat &lt;- t(scale(t(as.matrix(cem@expression[module_genes$genes,])))) ora_res &lt;- cem@ora terms2anno &lt;- ora_res %&gt;% dplyr::filter(p.adjust&lt;0.05) %&gt;% mutate(ID=gsub(&quot;_.*&quot;, &quot;&quot;, ID)) %&gt;% dplyr::select(Module, ID) %&gt;% dplyr::filter(Module!=&quot;Not.Correlated&quot;) terms2anno &lt;- split(terms2anno$ID, terms2anno$Module) col_scale &lt;- circlize::colorRamp2(breaks = c(-4,0,4), colors = c(&quot;dodgerblue4&quot;, &quot;white&quot;, &quot;darkorange&quot;)) row_annot &lt;- rowAnnotation(`GO ORA` = anno_word_cloud(module_genes$modules, terms2anno, max_words = 15, bg_gp = gpar(fill = &quot;white&quot;, col = &quot;black&quot;), fontsize_range=c(9,11)), gap = unit(0, &quot;mm&quot;), show_annotation_name=TRUE) top_anno = HeatmapAnnotation(Timepoint=gsub(&quot;.*._d&quot;, &quot;&quot;, colnames(exp_mat)), col = list(Timepoint=c(&quot;0&quot;=&quot;lightblue&quot;, &quot;3&quot;=&quot;dodgerblue&quot;, &quot;7&quot;=&quot;dodgerblue4&quot;))) draw(Heatmap(exp_mat, name=&quot;Expression (VST)&quot;, split = module_genes$modules, border=T, show_row_names = FALSE, show_column_names = FALSE, show_row_dend = FALSE, right_annotation = row_annot, top_annotation = top_anno, col = col_scale, heatmap_legend_param = list(legend_direction = &quot;horizontal&quot;)), merge_legends = T, heatmap_legend_side = &quot;bottom&quot;) We can also add annotation using other plotting tools, such as ggplot2 by generating a custom panel annotating function that uses indexes. Two of the four modules presented interesting results in the ORA. We can generate a function that creates Enrichment analysis bar plots for the modules and use that later with anno_zoom(). panel_fun_enr_results = function(index, nm) { # Get the module for selected indices mod &lt;- module_genes %&gt;% dplyr::filter(genes %in% rownames(exp_mat)[index]) %&gt;% .$modules %&gt;% unique() # Get top 5 hits from the ORA results res_toplot &lt;- ora_res %&gt;% dplyr::filter(Module %in% mod) %&gt;% mutate(ID=stringr::str_trunc(ID, 30)) %&gt;% arrange(p.adjust) %&gt;% slice_head(n=5) # Generate the plot g = ggplot(res_toplot, aes(x = -log10(p.adjust), y = forcats::fct_reorder(ID, -p.adjust), fill=FoldEnrichment)) + geom_bar(stat=&quot;identity&quot;, alpha=0.8, colour=&quot;black&quot;) + theme_bw(12) + scale_x_sqrt(expand=c(0,0), limits=c(0,25)) + scale_fill_gradientn(colours=c(&quot;turquoise&quot;, &quot;darkblue&quot;), breaks = c(0,50)) + geom_vline(xintercept = -log10(0.05)) + theme(axis.title.y = element_blank(), axis.text = element_text(colour=&quot;black&quot;), axis.ticks.length = unit(0.5, &quot;lines&quot;), axis.line = element_blank(), panel.border = element_rect(colour = &quot;black&quot;), legend.title = element_blank(), panel.grid = element_blank(), legend.position = &quot;none&quot;) # Make a grob and push it from viewport g = grid.grabExpr(print(g)) pushViewport(viewport()) grid.rect() grid.draw(g) popViewport() } We can now add the barplots for the indices that we define. In this case for M1 and M3. We can additionally add titles for the annotation boxes separately by pushing grid.text to view port. To list all available components of the plot for coordinate selection you can use list_components() from ComplexHeatmap. # interesting module indices ind_list &lt;- lapply(c(&quot;M1&quot;, &quot;M3&quot;), function(x) { # Get genes and positions genes &lt;- dplyr::filter(module_genes, modules %in% x)$genes which(rownames(exp_mat) %in% genes) }) # Generate row annotation row_annot &lt;- rowAnnotation(`GO ORA` = anno_zoom(align_to = ind_list, which = &quot;row&quot;, panel_fun = panel_fun_enr_results, # Set size for the annotation size = unit(5, &quot;cm&quot;), width = unit(10.5, &quot;cm&quot;))) # Generate top annotation top_anno = HeatmapAnnotation(Timepoint=gsub(&quot;.*._d&quot;, &quot;&quot;, colnames(exp_mat)), annotation_name_side = &quot;left&quot;, annotation_legend_param = list( Timepoint = list(legend_direction = &quot;horizontal&quot;)), col = list(Timepoint=c(&quot;0&quot;=&quot;lightblue&quot;, &quot;3&quot;=&quot;dodgerblue&quot;, &quot;7&quot;=&quot;dodgerblue4&quot;))) draw(Heatmap(exp_mat, name=&quot;Z-score&quot;, split = module_genes$modules, border=T, show_row_names = FALSE, show_column_names = FALSE, show_row_dend = FALSE, right_annotation = row_annot, top_annotation = top_anno, col = col_scale, heatmap_legend_param = list(direction = &quot;horizontal&quot;)), merge_legends = T, heatmap_legend_side = &quot;bottom&quot;, annotation_legend_side=&quot;bottom&quot;) seekViewport(&quot;annotation_Timepoint_1&quot;) loc1 = deviceLoc(x = unit(1.8, &quot;npc&quot;), y = unit(0, &quot;npc&quot;)) loc2 = deviceLoc(x = unit(1.8, &quot;npc&quot;), y = unit(-14.7, &quot;npc&quot;)) seekViewport(&quot;global&quot;) grid.text(&quot;M1 ORA results&quot;, x = loc1$x ,y = loc1$y) grid.text(&quot;M2 ORA results&quot;, x = loc2$x ,y = loc2$y) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
